define the quality<examples/abstract/math/adder> {
    # This allows the program dimension point to assign this quality
    # to dimension points.
    #
    # This is the one aspect of the syntax that creates circular
    # dependencies and thus does not require declaration before use.
    # However, if the compiler already knows this symbol
    # ("examples/program") then it can verify that this is valid now,
    # and otherwise, it will verify the symbol's validity when it
    # encounters the symbol (or spit out an error after validation)
    # is fully complete.
    #
    # The default is for a quality to be exposed only to itself.
    it may be assigned by quality<examples/program>.

    # The full name of this would be: potential_form<examples/abstract/math/adder::add>
    it defines the potential_form<add> {
        it contains the dimension points {
            this dimension point in view<self>.
            # TODO: This should just be a bag of two integers.
            a dimension point in position<first> {
                it has the quality<standard/integer>.
            }
            a dimension point in position<second> {
                it has the quality<standard/integer>.
            }
            a dimension point in view<result> {
                it has no quality.
            }
        }
    }
    it defines a trigger {
        we see potential_form<add> {
            is fully created.
            # form<args> is a name that exists only in the scope of this trigger.
            we call it form<args>.
        }
    } which then does {
        create a dimension point in form<args>::view<result>.
        assign the quality<Number> to form<args>::view<result> {
            # TODO: I'm shorthanding this because "adder" is a silly class.
            # Really this would be a call to something like standard/fundamental/math/adder.
            value: form<args>::position<first> + form<args>::position<second>
        }
    }
}

define the quality<examples/abstract/math/adder> {
    # This allows the program dimension point to assign this quality
    # to dimension points.
    #
    # This is the one aspect of the syntax that creates circular
    # dependencies and thus does not require declaration before use.
    # However, if the compiler already knows this symbol
    # ("examples/program") then it can verify that this is valid now,
    # and otherwise, it will verify the symbol's validity when it
    # encounters the symbol (or spit out an error after validation)
    # is fully complete.
    #
    # The default is for a quality to be exposed only to itself.
    it may be assigned by quality<examples/program>.

    # The full name of this would be: quality<examples/abstract/math/adder>::potential_form<add>
    it defines the potential_form<add> {
        it contains the dimension points {
            this dimension point.
            a dimension point in position<first> {
                it has the quality<standard/integer>.
            }
            a dimension point in position<second> {
                it has the quality<standard/integer>.
            }
            a dimension point in view<result> {
                it has no quality.
            }
        }
    }
    it triggers when {
        # form<args> is a name that exists only in the scope
        # of this trigger.
        potential_form<add> is fully created as form<args>.
    } and then does {
        create a dimension point in form<args>::view<result>.
        assign the quality<Number> to form<args>::view<result> {
            value: form<args>::position<first> + form<args>::position<second>
        }
    }

}

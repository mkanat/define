define the quality<examples/program> {
    # This is a way to define an entry point, because what the compiled
    # binary will do is create a dimension point and assign it the quality
    # that you indicate is the entry point.
    it defines a trigger {
        this dimension point {
            is assigned this quality.
        }
    } which then does {
        create a dimension point in position<adder>.
        assign the quality<examples/abstract/math/adder> to position<adder>.
        # TODO: The awkward part of this syntax is that you can't see what quality
        # this has, when you're reading the program.
        create a dimension point in position<result>.
        create a form<adder_args> {
            # TODO: We have to do this a lot, perhaps there should be a better syntax.
            it is intended to be potential_form<examples/abstract/math/adder::add>.
            create a view of position<adder> named view<self>.
            create a dimension point in position<first>.
            assign the quality<standard/integer> to position<first>.
            create a dimension point in position<second>.
            assign the quality<standard/integer> to position<second>.
            create a view of position<result> named view<result>.
        }
        # TODO: The compiler can actually figure this out itself.
        destroy the form<adder_args>.

        create a dimension point in position<terminal>.
        assign the quality<standard/terminal> to position<terminal>.
        # TODO: Error handling, perhaps just by having different qualities
        # of result?
        create a form<terminal_args> {
            it is intended to be potential_form<standard/terminal::output_integer_position>.
            create a view of position<terminal> named view<self>.
            move the dimension point position<result> into position<output_integer>.
        }
        destroy the form<terminal_args>.
    }
}
